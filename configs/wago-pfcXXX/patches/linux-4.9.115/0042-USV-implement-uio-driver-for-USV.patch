From 15f7ace1c716dc02d95aaa0e95b229e5156697d1 Mon Sep 17 00:00:00 2001
From: Oliver Schildan <oliver.schildan@wago.com>
Date: Wed, 12 Apr 2017 10:30:01 +0200
Subject: [PATCH 042/261] USV: implement uio driver for USV

Conflicts:
	arch/arm/boot/dts/wago-pfc200v3.dtsi
---
 arch/arm/boot/dts/wago-pfc200v3.dtsi        |  10 +
 arch/arm/configs/wago_pfc_generic_defconfig |   1 +
 arch/arm/mach-omap2/Kconfig                 |   5 +
 arch/arm/mach-omap2/Makefile                |   2 +
 arch/arm/mach-omap2/wusv.c                  | 274 ++++++++++++++++++++++++++++
 5 files changed, 292 insertions(+)
 create mode 100644 arch/arm/mach-omap2/wusv.c

diff --git a/arch/arm/boot/dts/wago-pfc200v3.dtsi b/arch/arm/boot/dts/wago-pfc200v3.dtsi
index e0154bf..172a479 100644
--- a/arch/arm/boot/dts/wago-pfc200v3.dtsi
+++ b/arch/arm/boot/dts/wago-pfc200v3.dtsi
@@ -12,6 +12,16 @@
 / {
 	model = "WAGO PFC200 V3 (AM33XX)";
 	compatible = "wago,pfc200v3", "ti,am33xx";
+
+	usv {
+		compatible = "wago,usvinit";
+
+		switch-reset = <&gpio3 10 GPIO_ACTIVE_LOW>;
+		kbus-reset =  <&gpio1 25 GPIO_ACTIVE_HIGH>;
+/*		USB-off = ; */
+/*		led-off = ; */	
+
+	};
 };
 
 &cpu_0 {
diff --git a/arch/arm/configs/wago_pfc_generic_defconfig b/arch/arm/configs/wago_pfc_generic_defconfig
index 735d8ab..91322f2 100644
--- a/arch/arm/configs/wago_pfc_generic_defconfig
+++ b/arch/arm/configs/wago_pfc_generic_defconfig
@@ -38,6 +38,7 @@ CONFIG_ARCH_OMAP3=y
 CONFIG_ARCH_OMAP4=y
 CONFIG_SOC_AM33XX=y
 CONFIG_WAGO_SYSTEM_BASED_STARTUP=y
+CONFIG_WAGO_USV=y
 # CONFIG_SOC_OMAP3430 is not set
 # CONFIG_SOC_TI81XX is not set
 # CONFIG_MACH_OMAP3517EVM is not set
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 834f552..b6c1d63 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -113,6 +113,11 @@ config WAGO_SYSTEM_BASED_STARTUP
        help
          Enable Wago System based startup code
 
+config WAGO_USV
+       bool "Wago USV startup code"
+       help
+         Enable Wago USV code
+
 config OMAP_INTERCONNECT_BARRIER
 	bool
 	select ARM_HEAVY_MB
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 8c7edaf..78bfd4f 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -259,3 +259,5 @@ obj-y					+= $(smsc911x-m) $(smsc911x-y)
 
 obj-y					+= common-board-devices.o twl-common.o dss-common.o
 obj-$(CONFIG_WAGO_SYSTEM_BASED_STARTUP)  += wsysinit.o wsysinit-boot-table.o wsysinit-testenv.o
+
+obj-$(CONFIG_WAGO_USV)  += wusv.o
diff --git a/arch/arm/mach-omap2/wusv.c b/arch/arm/mach-omap2/wusv.c
new file mode 100644
index 0000000..5788f31
--- /dev/null
+++ b/arch/arm/mach-omap2/wusv.c
@@ -0,0 +1,274 @@
+/*
+ * Wago USV Init Functions
+ *
+ * Copyright (C) 201xi74 WAGO Automation
+ *
+ * Author: WAGO Kontakttechnick 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG
+
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/kobject.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/tps65218.h>
+
+#include <asm/mach-types.h>
+
+#include <linux/delay.h>
+//#include <linux/wusv-devconf.h>
+//include <linux/wusv-prodcution.h>
+#include <linux/wsysinit-boot-table.h>
+
+#ifdef CONFIG_IRQ_PRIORITY_TABLE
+	#include <linux/wsysinit-prio.h>
+#endif
+
+#include <generated/utsrelease.h>
+
+#include <linux/timex.h>
+
+#include "soc.h"
+
+#define	DEVICE_NAME		"wusv-drv"
+
+char usv_data[]="wusv_drv tasklet startet";
+
+struct gpio_set {
+	int gpio_no;
+	int gpio_flag;	
+};
+
+struct wusv_settings {
+	bool 		wusv_init_sysfs;
+	int		gpio_irq;
+	int 		usv_irq;
+	const char 	*test_usv;
+	struct gpio_set	switch_reset;
+	struct gpio_set	kbus_reset;
+	struct gpio_set	led_reset;
+	struct gpio_set pmic_LS2;
+};
+
+static struct wusv_settings wusvset = { 0,};
+static dev_t wusv_dev;
+
+#ifdef CONFIG_OF
+static struct of_device_id wusv_dt_ids[] = {
+	{ .compatible = "wago,usvinit" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, wusv_dt_ids);
+
+
+void usv_active( unsigned long data )
+{
+  	pr_debug( "%s\n", (char *)data );
+	// begin to shutdown IP's
+	if( gpio_is_valid(wusvset.led_reset.gpio_no)) {
+		pr_debug("led_reset\n");
+		gpio_set_value(wusvset.led_reset.gpio_no, wusvset.led_reset.gpio_flag);	
+	}
+
+        if( gpio_is_valid(wusvset.switch_reset.gpio_no)) {
+                pr_debug("switch_reset\n");
+                gpio_set_value(wusvset.switch_reset.gpio_no, wusvset.switch_reset.gpio_flag);    
+        }
+
+        if( gpio_is_valid(wusvset.kbus_reset.gpio_no)) {
+                pr_debug("kbus_reset\n");
+                gpio_set_value(wusvset.kbus_reset.gpio_no, wusvset.kbus_reset.gpio_flag);    
+        }	
+
+	
+	
+	return;
+}
+
+
+DECLARE_TASKLET( tasklet_usv, usv_active, (unsigned long) &usv_data );
+
+static irqreturn_t usv_isr(int irq, void* dev)
+{
+	// start tasklet to shutdown IP's i.e. eth switch, ext phy, usb etc.
+	tasklet_schedule( &tasklet_usv );	
+
+        return IRQ_HANDLED;
+}
+
+
+
+static int wusv_init_probe_dt(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	enum of_gpio_flags flags;
+
+        pr_debug("WUSVINIT StartUp: probing device tree\n");
+
+        wusvset.wusv_init_sysfs = of_property_read_bool(np, "add-sysfs-entries");
+
+        wusvset.gpio_irq = of_get_named_gpio_flags(np, "usv_irq", 0, &flags);
+        if (wusvset.gpio_irq == -EPROBE_DEFER) {
+                ret = -EPROBE_DEFER;
+                goto out1;
+        }
+
+        wusvset.usv_irq = gpio_to_irq(wusvset.gpio_irq);
+        if( wusvset.usv_irq < 0) {
+                ret = wusvset.usv_irq;
+                goto out1;
+        }
+
+        ret = request_irq(wusvset.usv_irq, usv_isr, IRQF_TRIGGER_RISING | IRQF_THREAD_TBL_LOOKUP, "uio_alarm_usv", &wusv_dev);
+        if (ret) {
+                pr_err("%s: could not request irq %d: ret=%d\n", __func__, wusvset.usv_irq, ret);
+                goto out1;
+        }
+
+
+	wusvset.switch_reset.gpio_no = of_get_named_gpio_flags(np, "switch-reset", 0, &flags);
+        if (wusvset.switch_reset.gpio_no == -EPROBE_DEFER) {
+                ret = -EPROBE_DEFER;
+                goto out1;
+        }  else if (gpio_is_valid(wusvset.switch_reset.gpio_no)) {
+		wusvset.switch_reset.gpio_flag = flags;	
+	}
+
+	wusvset.kbus_reset.gpio_no = of_get_named_gpio_flags(np, "kbus-reset", 0, &flags);
+        if (wusvset.kbus_reset.gpio_no == -EPROBE_DEFER) {
+                ret = -EPROBE_DEFER;
+                goto out1;
+        } else if (gpio_is_valid(wusvset.kbus_reset.gpio_no)) {
+		wusvset.switch_reset.gpio_flag = flags;
+	}
+
+	wusvset.led_reset.gpio_no = of_get_named_gpio_flags(np, "led-off", 0, &flags);
+        if (wusvset.led_reset.gpio_no == -EPROBE_DEFER) {
+                ret = -EPROBE_DEFER;
+                goto out1;
+	} else if (gpio_is_valid(wusvset.led_reset.gpio_no)) {
+		wusvset.led_reset.gpio_flag = flags;
+		pr_debug("wusvset.led_reset.gpio_flag = %d ::::::: wusvset.led_reset.gpio_no = %d", wusvset.led_reset.gpio_flag, wusvset.led_reset.gpio_no);
+	}
+
+	wusvset.pmic_LS2.gpio_no = of_get_named_gpio_flags(np, "USB-off", 0, &flags);
+        if (wusvset.pmic_LS2.gpio_no == -EPROBE_DEFER) {
+                ret = -EPROBE_DEFER;
+                goto out1;
+	} else if (gpio_is_valid(wusvset.pmic_LS2.gpio_no)) {
+		wusvset.pmic_LS2.gpio_flag = flags;
+		pr_debug("wusvset.pmicLS2.gpio_flag = %d ::::::: wusvset.pmic_LS2.gpio_no = %d", wusvset.pmic_LS2.gpio_flag, wusvset.pmic_LS2.gpio_no);
+	}
+
+
+out1:
+	return ret;
+}
+#else
+static int wusv_init_probe_dt(struct platform_device *pdev)
+{
+	return 0;
+}
+#endif
+
+
+/* WUSVINIT SYSFS Init */
+
+static dev_t wusv_sysfs_dev;
+struct class* wusv_sysfs_class = NULL;
+struct device* wusv_sysfs_device = NULL;
+EXPORT_SYMBOL(wusv_sysfs_class);
+EXPORT_SYMBOL(wusv_sysfs_device);
+
+ssize_t wusv_sysfs_test_usv_show(struct device* dev, struct device_attribute* attr, char* buf)
+{
+	sprintf(buf, "USV\n");
+	return strlen(buf);
+}
+
+DEVICE_ATTR (    test_usv, 0444,   wusv_sysfs_test_usv_show, NULL);
+
+static void wusv_sysfs_init(void)
+{
+	device_create_file(wusv_sysfs_device, &dev_attr_test_usv);
+}
+
+static int wusv_init_probe(struct platform_device *pdev)
+{
+	int rc;
+
+	if (!pdev->dev.of_node) {
+		dev_err(&pdev->dev, "WUSV Init: No DT node found!\n");
+		return -1;
+	}
+
+	rc = wusv_init_probe_dt(pdev);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to probe DT parameters\n");
+		return rc;
+	}
+
+	if (wusvset.wusv_init_sysfs)
+		wusv_sysfs_init();
+
+	pr_info("Wago WUSV Init: %s probed.\n", pdev->dev.of_node->name);
+
+	return 0;
+}
+
+static int wusv_init_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver wusv_init_driver = {
+	.probe		= wusv_init_probe,
+	.remove		= wusv_init_remove,
+	.driver		= {
+		.name	= DEVICE_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(wusv_dt_ids),
+	},
+};
+
+static __init int wusv_init(void)
+{
+	pr_info("WUSVINIT: create sysfs entries\n");
+
+	wusv_sysfs_class = class_create (THIS_MODULE, "wago_usv");
+	if (IS_ERR(wusv_sysfs_class)) {
+
+		pr_err("%s: class_create: error %li\n",
+			__func__, PTR_ERR(wusv_sysfs_class));
+		unregister_chrdev_region(wusv_sysfs_dev, 1);
+		return -1;
+	}
+
+	wusv_sysfs_device = device_create (wusv_sysfs_class, NULL,
+                        wusv_sysfs_dev, NULL, "usv");
+
+	return platform_driver_register(&wusv_init_driver);
+}
+
+static __exit void wusv_exit(void)
+{
+	tasklet_schedule( &tasklet_usv );
+	platform_driver_unregister(&wusv_init_driver);
+}
+
+omap_postcore_initcall(wusv_init);
+module_exit(wusv_exit);
-- 
2.7.4

